import glob
import os
from pathlib import Path
import datetime

# utilities involving filespace and strings

SELF_NAME = "pfondum"
NOW = datetime.datetime.now()


def raw(data):
    return isinstance(data, (bytes, bytearray))


def create_dir(file_path):
    p = Path(file_path)
    p.mkdir(parents=True, exist_ok=True)


def copy_dir(source_dir, destination_dir, verbose=False, interpret=True):
    trim = len(source_dir)
    raw_source_files = glob.glob(source_dir + "/**", recursive=True)
    source_files = []
    source_subdirs = []
    for filepath in raw_source_files:
        if not filepath.startswith(source_dir):  # skip softlinks
            continue
        filename = filepath[trim:]
        if os.path.isdir(filepath):
            source_subdirs.append(filename[1:])
        else:
            source_files.append(filename[1:])
    for subdir in source_subdirs:
        create_dir("{}/{}".format(destination_dir, subdir))
        if verbose is True:
            print("    > subdirectory /{}".format(subdir))
    for filename in source_files:
        copy_file(filename, source_dir, destination_dir, verbose=verbose, interpret=interpret)
    return


def copy_file(filepath, source_dir, destination_dir, verbose=False, interpret=True):
    if source_dir:
        full_file_path = "{}/{}".format(source_dir, filepath)
    else:
        full_file_path = filepath
    with open(full_file_path, "rb") as file:
        raw_data = file.read()
    (subdir, file_name) = os.path.split(filepath)
    (file_base, extension) = os.path.splitext(file_name)
    extension = extension.lower()
    final_data = raw_data  # default
    if extension == ".py":
        filetype = "python"
        if interpret:
            final_data = parse_python(raw_data, full_file_path)
    elif extension == ".html":
        filetype = "HTML"
        if interpret:
            final_data = parse_html(raw_data, filepath)
    else:
        filetype = "unknown"
    if raw(final_data):
        with open("{}/{}".format(destination_dir, filepath), "wb") as file:
            file.write(final_data)
            file.close()
    else:
        with open("{}/{}".format(destination_dir, filepath), "w") as file:
            file.write(final_data)
            file.close()
    if verbose is True:
        print("    > {} [type {}]".format(filepath, filetype))
    return


def parse_python(raw_data, source):
    final_text = "# DO NOT EDIT. This file was autogenerated by {}.\n".format(SELF_NAME)
    final_text += '#     source file pulled from "{}"\n'.format("elsewhere")
    final_text += "\n"
    final_text += raw_data.decode('utf-8')
    return final_text


def parse_html(raw_data, source):
    # for security reasons, do not include full directory in 'source' as it will be seen by the public!
    final_text = "<!-- # DO NOT EDIT. This file was autogenerated from {}. -->\n".format("elsewhere")
    final_text += raw_data.decode('utf-8')
    return final_text

def pretty_dictionary(d, varname):
    t = ""
    t += '{} = {{\n'.format(varname)
    for key in sorted(d):
        temp = repr(d[key])
        if temp.startswith("{"):
            t += '    "{}": {{\n'.format(key)
            for subkey in sorted(d[key]):
                t += '        "{}": {},\n'.format(subkey, repr(d[key][subkey]))
            t += '    },\n'
        elif temp.startswith("["):
            t += '    "{}": [\n'.format(key)
            t += ",\n".join(['        {}'.format(repr(item)) for item in d[key]])
            t += "\n"
            t += '    ],\n'
        else:
            t += '    "{}": {},\n'.format(key, temp)
    t += "}\n"
    return t


def tabbed_text(text_list, tab_size=4, width=79):
    t = " " * tab_size
    w = width - len(t) - 2
    new_list = []
    for line in text_list:
        if len(line) > w:
            new_list.extend(size_split(line, w))
        else:
            new_list.append(line)
    return "\n".join(["{}> {}".format(t, e) for e in new_list])


def size_split(s, n):
    def _f(s, n):
        while s:
            yield s[:n]
            s = s[n:]
    return list(_f(s, n))


def file_dict_swapper(filename, data):
    with open(filename) as f:
        text = f.read()
    for k, v in data.items():
        target = "{{{{{key}}}}}".format(key=k)
        text = text.replace(target, v)
    with open(filename, "w+") as f:
        f.write(text)
    return

# eof
